/**
 * generate CLAUDE.md from preset rules and skills.
 * TypeScript port of v1 generate-claude-md.mjs.
 */

import { readFileSync, readdirSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import { RULE_SKILL_MAP, RULE_WORKFLOW_ID } from './constants.js';
import type { SkillMatcher } from '../domain/skill-matcher/matcher.js';
import type { SkillSummary } from '../domain/skill-matcher/types.js';

interface RulePreset {
  id: string;
  name: string;
  description: string;
  priority: string | number;
  content: string;
  category?: string;
  tags?: string[];
}

interface SkillInfo {
  name: string;
  description: string;
}

const PRIORITY_ORDER: Record<string, number> = {
  critical: 0,
  high: 1,
  medium: 2,
  low: 3,
};

/**
 * Generate CLAUDE.md content from rules and skills in the given presets directory.
 * When a SkillMatcher is provided, uses AI semantic matching instead of RULE_SKILL_MAP.
 */
export async function generateClaudeMd(
  presetsDir: string,
  skillMatcher?: SkillMatcher,
): Promise<string> {
  const rulesDir = join(presetsDir, 'rules');
  const skillsDir = join(presetsDir, 'skills');

  const rules = loadRules(rulesDir);
  const skills = loadSkills(skillsDir);

  // Build SkillSummary list for AI matching
  let skillSummaries: SkillSummary[] | undefined;
  if (skillMatcher) {
    skillSummaries = skills.map((s) => ({
      name: s.name,
      description: s.description,
      tags: [],
    }));
  }

  const rulesSection = await generateRulesSection(rules, skillMatcher, skillSummaries);

  const sections = [
    '# Claude Habitat Rules',
    '',
    'This file is auto-generated by claude-habitat from preset rules and skills.',
    '',
    generateSkillsSection(skills),
    rulesSection,
    generateWorkflowSection(rules),
    '',
  ];

  return sections.join('\n');
}

function loadRules(rulesDir: string): RulePreset[] {
  if (!existsSync(rulesDir)) return [];

  return readdirSync(rulesDir)
    .filter((f) => f.endsWith('.json'))
    .map((f) => {
      try {
        return JSON.parse(readFileSync(join(rulesDir, f), 'utf-8')) as RulePreset;
      } catch {
        return null;
      }
    })
    .filter((r): r is RulePreset => r !== null)
    .sort((a, b) => {
      const pa = typeof a.priority === 'number' ? a.priority : (PRIORITY_ORDER[a.priority] ?? 99);
      const pb = typeof b.priority === 'number' ? b.priority : (PRIORITY_ORDER[b.priority] ?? 99);
      return pa - pb;
    });
}

function loadSkills(skillsDir: string): SkillInfo[] {
  if (!existsSync(skillsDir)) return [];

  return readdirSync(skillsDir)
    .filter((f) => f.endsWith('.md'))
    .map((f) => {
      const content = readFileSync(join(skillsDir, f), 'utf-8');
      const name = f.replace(/\.md$/, '');
      const description = extractDescription(content);
      return { name, description };
    })
    .filter((s) => s.name);
}

function extractDescription(content: string): string {
  if (content.startsWith('---')) {
    const endIdx = content.indexOf('---', 3);
    if (endIdx !== -1) {
      const frontmatter = content.slice(3, endIdx);
      const descMatch = frontmatter.match(/^description:\s*(.+)$/m);
      if (descMatch) return descMatch[1].trim();
    }
  }

  const lines = content.split('\n');
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    if (line.startsWith('#')) {
      for (let j = i + 1; j < lines.length; j++) {
        const descMatch = lines[j].match(/\*\*Description\*\*:\s*(.+)/);
        if (descMatch) return descMatch[1].trim();
        if (lines[j].startsWith('#')) break;
      }
      break;
    }
    if (line.startsWith('Tags:')) continue;
    return line;
  }
  return '';
}

function generateSkillsSection(skills: SkillInfo[]): string {
  if (skills.length === 0) return '';

  const lines = [
    '## Available Skills',
    '',
    'When working on tasks, consider using the `habitat_skill_resolve` MCP tool to load structured protocols:',
    '',
  ];

  for (const skill of skills) {
    const desc = skill.description ? ` â€” ${skill.description}` : '';
    lines.push(`- **${skill.name}**${desc}`);
  }

  lines.push('');
  lines.push('Usage: Call `habitat_skill_resolve` with the skill name to get step-by-step guidance.');
  lines.push('');

  return lines.join('\n');
}

async function generateRulesSection(
  rules: RulePreset[],
  skillMatcher?: SkillMatcher,
  availableSkills?: SkillSummary[],
): Promise<string> {
  if (rules.length === 0) return '';

  const lines = ['## Rules', ''];

  for (const rule of rules) {
    lines.push(rule.content);

    let skillNames: string[] = [];
    if (skillMatcher && availableSkills) {
      const results = await skillMatcher.matchRule(
        {
          id: rule.id,
          name: rule.name,
          description: rule.description ?? '',
          category: rule.category ?? 'general',
          tags: rule.tags ?? [],
        },
        availableSkills,
      );
      skillNames = results.map((r) => r.skillName);
    } else {
      // Fallback to static RULE_SKILL_MAP
      skillNames = RULE_SKILL_MAP[rule.id] ?? [];
    }

    if (skillNames.length > 0) {
      lines.push('');
      const skillRefs = skillNames.map((s) => `\`habitat_skill_resolve("${s}")\``).join(' or ');
      lines.push(
        `> **REQUIRED:** When this rule applies, you MUST call ${skillRefs} to load the protocol and follow its steps.`,
      );
    }
    lines.push('');
  }

  return lines.join('\n');
}

function generateWorkflowSection(rules: RulePreset[]): string {
  const workflowRule = rules.find((r) => r.id === RULE_WORKFLOW_ID);
  if (!workflowRule) return '';

  return workflowRule.content;
}
